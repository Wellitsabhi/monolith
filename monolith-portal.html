<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Monolith Portal</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

html.lenis, html.lenis body { height: auto; }
.lenis.lenis-smooth { scroll-behavior: auto !important; }

body { 
  font-family: 'Courier New', monospace; 
  background: #000; 
  color: #fff; 
  overflow-x: hidden;
}

#root { width: 100vw; min-height: 100vh; }

::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: #0a1a10; }
::-webkit-scrollbar-thumb { background: #2a8a5a; border-radius: 2px; }

@keyframes pulseIndicator {
  0%, 100% { opacity: 0.3; transform: translateY(0); }
  50% { opacity: 1; transform: translateY(-5px); }
}
</style>
</head>
<body>
<div id="root"></div>

<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/lenis@1.1.13/dist/lenis.min.js"></script>
<script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js"></script>

<script type="text/babel">
const { useState, useEffect, useRef } = React;

const MonolithPortal = () => {
  const containerRef = useRef(null);
  const canvasRef = useRef(null);
  const textBottomLeftRef = useRef(null);
  const textBottomCenterRef = useRef(null);
  const line1Ref = useRef(null);
  const line2Ref = useRef(null);
  const bgImageRef = useRef(null);
  const whiteOverlayRef = useRef(null);
  
  const [scrollProgress, setScrollProgress] = useState(0);

  useEffect(() => {
    // ============================================
    // LENIS SMOOTH SCROLL
    // ============================================
    const lenis = new Lenis({
      duration: 1.4,
      easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
      smoothWheel: true,
      wheelMultiplier: 0.8,
    });

    lenis.on('scroll', ScrollTrigger.update);
    gsap.ticker.add((time) => lenis.raf(time * 1000));
    gsap.ticker.lagSmoothing(0);

    // ============================================
    // COLOR PALETTE
    // ============================================
    const colors = {
      primary: 0x3da67a,
      glow: 0x5fcf9f,
      dark: 0x1a4a35,
      white: 0xffffff,
      spark: 0x8fffcc
    };

    // ============================================
    // THREE.JS SETUP
    // ============================================
    const canvas = canvasRef.current;
    const scene = new THREE.Scene();
    
    const cam = new THREE.PerspectiveCamera(
      75, 
      window.innerWidth / window.innerHeight, 
      1, 
      10000
    );
    cam.position.z = 1000;
    scene.add(cam);
    
    const renderer = new THREE.WebGLRenderer({ 
      canvas, 
      alpha: true,
      antialias: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // ============================================
    // LIGHTING
    // ============================================
    const ambientLight = new THREE.AmbientLight(0x1a3a2a, 0.3);
    scene.add(ambientLight);

    const portalLight = new THREE.PointLight(colors.glow, 0, 800, 1.5);
    portalLight.position.set(150, -100, 100); // Positioned where portal will form (right of monolith base)
    scene.add(portalLight);

    const centerLight = new THREE.PointLight(0xffffff, 0, 400, 2);
    centerLight.position.set(150, -100, 50);
    scene.add(centerLight);

    // ============================================
    // TEXTURES
    // ============================================
    const createSmokeTexture = () => {
      const c = document.createElement('canvas');
      c.width = 128;
      c.height = 128;
      const ctx = c.getContext('2d');
      const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
      gradient.addColorStop(0.3, 'rgba(200, 255, 230, 0.3)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 128, 128);
      return new THREE.CanvasTexture(c);
    };

    const createSparkTexture = () => {
      const c = document.createElement('canvas');
      c.width = 32;
      c.height = 32;
      const ctx = c.getContext('2d');
      const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
      gradient.addColorStop(0.2, 'rgba(180, 255, 220, 0.8)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 32, 32);
      return new THREE.CanvasTexture(c);
    };

    // Create character texture
    const createCharacterTexture = (char) => {
      const c = document.createElement('canvas');
      c.width = 64;
      c.height = 64;
      const ctx = c.getContext('2d');
      
      ctx.shadowBlur = 12;
      ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
      
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 36px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(char, 32, 32);
      
      ctx.shadowBlur = 6;
      ctx.fillText(char, 32, 32);
      
      return new THREE.CanvasTexture(c);
    };

    const smokeTexture = createSmokeTexture();
    const sparkTexture = createSparkTexture();

    // Characters pool
    const characters = 'MOTIONMODEXYSMOTIONMODEXYSMOTIONMODEXYSMOTIONMODEXYSMOTIONMODEXYSMOTIONMODEXYSMOTIONMODEXYSMOTIONMODEXYS'.split('');

    // Pre-create textures
    const charTextures = {};
    characters.forEach(char => {
      charTextures[char] = createCharacterTexture(char);
    });

    // ============================================
    // PORTAL GROUP - Positioned to right of monolith base (where man stands)
    // ============================================
    const portalGroup = new THREE.Group();
    portalGroup.position.set(150, -80, 50); // Right side, lower area
    scene.add(portalGroup);

    // ============================================
    // PORTAL RING (TORUS)
    // ============================================
    const ringGeometry = new THREE.TorusBufferGeometry(200, 12, 16, 100);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: colors.primary,
      transparent: true,
      opacity: 0
    });
    const portalRing = new THREE.Mesh(ringGeometry, ringMaterial);
    portalGroup.add(portalRing);

    // Outer glow ring
    const glowRingGeo = new THREE.TorusBufferGeometry(200, 30, 16, 100);
    const glowRingMat = new THREE.MeshBasicMaterial({
      color: colors.glow,
      transparent: true,
      opacity: 0,
      blending: THREE.AdditiveBlending
    });
    const glowRing = new THREE.Mesh(glowRingGeo, glowRingMat);
    portalGroup.add(glowRing);

    // ============================================
    // CENTER GLOW - Start at portal size, no ripple
    // ============================================
    const centerGlowGeo = new THREE.CircleBufferGeometry(200, 64); // Same size as portal
    const centerGlowMat = new THREE.ShaderMaterial({
      transparent: true,
      blending: THREE.AdditiveBlending,
      uniforms: {
        opacity: { value: 0 },
        time: { value: 0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float opacity;
        uniform float time;
        varying vec2 vUv;
        
        void main() {
          float dist = length(vUv - vec2(0.5)) * 2.0;
          
          // Solid white center that fills the portal
          float glow = 1.0 - smoothstep(0.0, 1.0, dist);
          glow = pow(glow, 0.8);
          
          // Subtle pulse
          glow *= 0.9 + 0.1 * sin(time * 2.0);
          
          // Pure white with slight green tint at edges
          vec3 color = mix(vec3(1.0), vec3(0.8, 1.0, 0.9), dist * 0.3);
          
          gl_FragColor = vec4(color, glow * opacity);
        }
      `
    });
    const centerGlow = new THREE.Mesh(centerGlowGeo, centerGlowMat);
    centerGlow.position.z = -5;
    portalGroup.add(centerGlow);

    // ============================================
    // DUST/CLOUD PARTICLES AROUND RING
    // ============================================
    const dustParticles = [];
    const dustGeo = new THREE.PlaneBufferGeometry(80, 80);
    
    for (let i = 0; i < 120; i++) {
      const dustMat = new THREE.MeshBasicMaterial({
        map: smokeTexture,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      const dust = new THREE.Mesh(dustGeo, dustMat);
      
      const angle = Math.random() * Math.PI * 2;
      const radius = 180 + Math.random() * 80;
      const zOffset = (Math.random() - 0.5) * 60;
      
      dust.position.set(
        Math.cos(angle) * radius,
        Math.sin(angle) * radius,
        zOffset
      );
      dust.rotation.z = Math.random() * Math.PI * 2;
      dust.userData = { 
        angle, 
        radius, 
        speed: 0.2 + Math.random() * 0.3,
        zOffset 
      };
      
      dustParticles.push(dust);
      portalGroup.add(dust);
    }

    // ============================================
    // SPARK PARTICLES
    // ============================================
    const sparkParticles = [];
    const sparkGeo = new THREE.PlaneBufferGeometry(8, 8);
    
    for (let i = 0; i < 60; i++) {
      const sparkMat = new THREE.MeshBasicMaterial({
        map: sparkTexture,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      const spark = new THREE.Mesh(sparkGeo, sparkMat);
      
      const angle = Math.random() * Math.PI * 2;
      const radius = 160 + Math.random() * 100;
      
      spark.position.set(
        Math.cos(angle) * radius,
        Math.sin(angle) * radius,
        (Math.random() - 0.5) * 40
      );
      
      spark.userData = {
        angle,
        baseRadius: radius,
        speed: 0.5 + Math.random() * 0.5,
        flickerSpeed: 5 + Math.random() * 10,
        phase: Math.random() * Math.PI * 2
      };
      
      sparkParticles.push(spark);
      portalGroup.add(spark);
    }

    // ============================================
    // ENERGY WAVES
    // ============================================
    const energyWaves = [];
    for (let i = 0; i < 3; i++) {
      const waveGeo = new THREE.RingBufferGeometry(195, 210, 64);
      const waveMat = new THREE.MeshBasicMaterial({
        color: colors.glow,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide
      });
      const wave = new THREE.Mesh(waveGeo, waveMat);
      wave.userData = { phase: i * (Math.PI * 2 / 3) };
      energyWaves.push(wave);
      portalGroup.add(wave);
    }

    // ============================================
    // MATRIX-STYLE VERTICAL LETTER COLUMNS
    // ============================================
    const matrixColumns = [];
    const numColumns = 4;
    const charsPerColumn = 25;
    const columnSpacing = 35; // Space between columns
    const charHeight = 22; // Vertical spacing between chars
    const columnHeight = charsPerColumn * charHeight;
    const monolithCenterX = -50; // Monolith is left of center
    
    // Create column group (positioned on monolith surface)
    const matrixGroup = new THREE.Group();
    matrixGroup.position.set(monolithCenterX, 0, 150);
    scene.add(matrixGroup);
    
    // Portal position in world space (for flying destination)
    const portalWorldPos = new THREE.Vector3(150, -80, 50);

    for (let col = 0; col < numColumns; col++) {
      const columnChars = [];
      const colX = (col - (numColumns - 1) / 2) * columnSpacing;
      
      // Alternate direction: some go up, some go down
      const direction = col % 2 === 0 ? 1 : -1;
      
      for (let i = 0; i < charsPerColumn; i++) {
        const char = characters[Math.floor(Math.random() * characters.length)];
        
        const charMat = new THREE.MeshBasicMaterial({
          map: charTextures[char],
          transparent: true,
          opacity: 0,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        
        const charGeo = new THREE.PlaneBufferGeometry(18, 18);
        const charMesh = new THREE.Mesh(charGeo, charMat);
        
        // Position in column
        const startY = (i - charsPerColumn / 2) * charHeight;
        charMesh.position.set(colX, startY, 0);
        
        // End position on portal ring (in portal's local space, then we'll transform)
        const endAngle = Math.random() * Math.PI * 2;
        const endRadius = 180 + Math.random() * 40;
        
        charMesh.userData = {
          column: col,
          index: i,
          direction: direction,
          speed: 80 + Math.random() * 40, // Scroll speed
          baseY: startY,
          colX: colX,
          // For soft fade mask
          normalizedPos: i / charsPerColumn, // 0 to 1
          // For flying to portal
          endAngle: endAngle,
          endRadius: endRadius,
          endPos: new THREE.Vector3(
            Math.cos(endAngle) * endRadius,
            Math.sin(endAngle) * endRadius,
            (Math.random() - 0.5) * 30
          ),
          flyDelay: Math.random() * 0.8,
          char: char
        };
        
        columnChars.push(charMesh);
        matrixGroup.add(charMesh);
      }
      matrixColumns.push(columnChars);
    }

    // Flatten for easy access
    const allMatrixChars = matrixColumns.flat();

    // ============================================
    // FLASH PLANE (for tunnel white flash)
    // ============================================
    const flashGeo = new THREE.PlaneBufferGeometry(4000, 4000);
    const flashMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0
    });
    const flashPlane = new THREE.Mesh(flashGeo, flashMat);
    flashPlane.position.z = 500;
    scene.add(flashPlane);

    // ============================================
    // 3D ABOUT SECTION
    // ============================================
    const createAboutTexture = () => {
      const c = document.createElement('canvas');
      c.width = 1920;
      c.height = 1080;
      const ctx = c.getContext('2d');
      
      // Background
      const grad = ctx.createLinearGradient(0, 0, 0, 1080);
      grad.addColorStop(0, '#0a1f15');
      grad.addColorStop(0.5, '#051210');
      grad.addColorStop(1, '#020a08');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 1920, 1080);
      
      // Subtle grid
      ctx.strokeStyle = 'rgba(61, 166, 122, 0.06)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 1920; i += 60) {
        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, 1080); ctx.stroke();
      }
      for (let i = 0; i < 1080; i += 60) {
        ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(1920, i); ctx.stroke();
      }
      
      // Title
      ctx.shadowBlur = 50;
      ctx.shadowColor = 'rgba(61, 166, 122, 0.8)';
      ctx.fillStyle = '#5fcf9f';
      ctx.font = 'bold 72px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('ABOUT THE MONOLITH', 960, 150);
      
      // Subtitle
      ctx.shadowBlur = 20;
      ctx.font = '24px Courier New';
      ctx.fillStyle = 'rgba(95, 207, 159, 0.7)';
      ctx.fillText('Beyond the Portal • Another Dimension', 960, 200);
      
      // Divider
      ctx.shadowBlur = 15;
      const lineGrad = ctx.createLinearGradient(300, 0, 1620, 0);
      lineGrad.addColorStop(0, 'transparent');
      lineGrad.addColorStop(0.2, '#3da67a');
      lineGrad.addColorStop(0.8, '#3da67a');
      lineGrad.addColorStop(1, 'transparent');
      ctx.strokeStyle = lineGrad;
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(300, 240); ctx.lineTo(1620, 240); ctx.stroke();
      
      // Body text
      ctx.shadowBlur = 0;
      ctx.textAlign = 'left';
      ctx.fillStyle = '#aaccbb';
      ctx.font = '22px Courier New';
      
      const paragraphs = [
        'Lorem ipsum dolor sit amet, consectetur adipiscing elit.',
        'Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.',
        'Ut enim ad minim veniam, quis nostrud exercitation ullamco.',
        '',
        'Duis aute irure dolor in reprehenderit in voluptate velit esse.',
        'Excepteur sint occaecat cupidatat non proident, sunt in culpa.',
      ];
      paragraphs.forEach((t, i) => ctx.fillText(t, 200, 310 + i * 38));
      
      // Feature boxes
      ctx.shadowBlur = 15;
      ctx.shadowColor = 'rgba(61, 166, 122, 0.4)';
      ctx.strokeStyle = 'rgba(61, 166, 122, 0.5)';
      ctx.lineWidth = 2;
      
      // Box 1
      ctx.strokeRect(200, 550, 450, 200);
      ctx.fillStyle = 'rgba(61, 166, 122, 0.08)';
      ctx.fillRect(200, 550, 450, 200);
      ctx.shadowBlur = 25;
      ctx.fillStyle = '#5fcf9f';
      ctx.font = 'bold 28px Courier New';
      ctx.fillText('Dimension Alpha', 240, 610);
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#8ab8a0';
      ctx.font = '18px Courier New';
      ctx.fillText('The first realm beyond the portal.', 240, 660);
      ctx.fillText('Reality bends to consciousness.', 240, 690);
      ctx.fillText('Time flows differently here.', 240, 720);
      
      // Box 2
      ctx.shadowBlur = 15;
      ctx.strokeRect(720, 550, 450, 200);
      ctx.fillStyle = 'rgba(61, 166, 122, 0.08)';
      ctx.fillRect(720, 550, 450, 200);
      ctx.shadowBlur = 25;
      ctx.fillStyle = '#5fcf9f';
      ctx.font = 'bold 28px Courier New';
      ctx.fillText('Quantum Matrix', 760, 610);
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#8ab8a0';
      ctx.font = '18px Courier New';
      ctx.fillText('The structure connecting all.', 760, 660);
      ctx.fillText('Navigate infinite possibilities.', 760, 690);
      ctx.fillText('Parallel realities converge.', 760, 720);
      
      // Box 3
      ctx.shadowBlur = 15;
      ctx.strokeRect(1240, 550, 450, 200);
      ctx.fillStyle = 'rgba(61, 166, 122, 0.08)';
      ctx.fillRect(1240, 550, 450, 200);
      ctx.shadowBlur = 25;
      ctx.fillStyle = '#5fcf9f';
      ctx.font = 'bold 28px Courier New';
      ctx.fillText('Energy Nexus', 1280, 610);
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#8ab8a0';
      ctx.font = '18px Courier New';
      ctx.fillText('Pure dimensional energy flows.', 1280, 660);
      ctx.fillText('Harness the cosmic current.', 1280, 690);
      ctx.fillText('Become one with the void.', 1280, 720);
      
      // Welcome box
      ctx.shadowBlur = 30;
      ctx.shadowColor = 'rgba(61, 166, 122, 0.5)';
      ctx.strokeStyle = 'rgba(95, 207, 159, 0.6)';
      ctx.lineWidth = 3;
      ctx.strokeRect(200, 820, 1520, 140);
      const welcomeGrad = ctx.createLinearGradient(200, 820, 1720, 960);
      welcomeGrad.addColorStop(0, 'rgba(61, 166, 122, 0.15)');
      welcomeGrad.addColorStop(1, 'rgba(61, 166, 122, 0.03)');
      ctx.fillStyle = welcomeGrad;
      ctx.fillRect(200, 820, 1520, 140);
      
      ctx.shadowBlur = 40;
      ctx.fillStyle = '#5fcf9f';
      ctx.font = 'bold 36px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('Welcome to the Other Side', 960, 880);
      
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#8ab8a0';
      ctx.font = '20px Courier New';
      ctx.fillText('You have successfully traversed the dimensional portal. This is your destination.', 960, 925);
      
      // Footer
      ctx.fillStyle = 'rgba(95, 207, 159, 0.4)';
      ctx.font = '14px Courier New';
      ctx.fillText('━━━━━━━━━━  TRANSMISSION COMPLETE  ━━━━━━━━━━', 960, 1020);
      
      return new THREE.CanvasTexture(c);
    };

    const aboutTexture = createAboutTexture();
    
    const vFov = cam.fov * Math.PI / 180;
    const targetDistance = 800;
    const planeHeight = 2 * Math.tan(vFov / 2) * targetDistance;
    const planeWidth = planeHeight * (window.innerWidth / window.innerHeight);
    
    const aboutGeometry = new THREE.PlaneBufferGeometry(planeWidth, planeHeight);
    const aboutMaterial = new THREE.MeshBasicMaterial({
      map: aboutTexture,
      transparent: true,
      opacity: 0
    });
    
    const aboutMesh = new THREE.Mesh(aboutGeometry, aboutMaterial);
    aboutMesh.position.set(portalGroup.position.x, portalGroup.position.y, -2500); // Behind portal
    scene.add(aboutMesh);

    const finalAboutZ = portalGroup.position.z + 150;
    const finalCamZ = finalAboutZ + targetDistance;

    // ============================================
    // ANIMATION STATE
    // ============================================
    let matrixScrolling = false;
    let charsFlying = false;

    // ============================================
    // ANIMATION LOOP
    // ============================================
    const clock = new THREE.Clock();
    let animationId;
    
    const animate = () => {
      animationId = requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const elapsed = clock.getElapsedTime();

      // Rotate portal group slowly
      portalGroup.rotation.z += delta * 0.15;

      // ============================================
      // MATRIX SCROLLING ANIMATION (when active)
      // ============================================
      if (matrixScrolling && !charsFlying) {
        allMatrixChars.forEach(char => {
          const data = char.userData;
          
          // Move vertically based on direction
          char.position.y += data.direction * data.speed * delta;
          
          // Wrap around (infinite scroll)
          const halfHeight = columnHeight / 2;
          if (data.direction > 0 && char.position.y > halfHeight) {
            char.position.y = -halfHeight;
            // Randomize character on wrap
            const newChar = characters[Math.floor(Math.random() * characters.length)];
            char.material.map = charTextures[newChar];
          } else if (data.direction < 0 && char.position.y < -halfHeight) {
            char.position.y = halfHeight;
            const newChar = characters[Math.floor(Math.random() * characters.length)];
            char.material.map = charTextures[newChar];
          }
          
          // Soft fade at edges (top and bottom)
          const normalizedY = (char.position.y + halfHeight) / columnHeight; // 0 to 1
          const edgeFade = Math.sin(normalizedY * Math.PI); // 0 at edges, 1 in middle
          const targetOpacity = Math.pow(edgeFade, 0.5) * 0.9;
          
          if (char.material.userData.baseOpacity !== undefined) {
            char.material.opacity = targetOpacity * char.material.userData.baseOpacity;
          }
        });
      }

      // Animate dust particles around ring
      dustParticles.forEach(dust => {
        dust.userData.angle += delta * dust.userData.speed;
        dust.position.x = Math.cos(dust.userData.angle) * dust.userData.radius;
        dust.position.y = Math.sin(dust.userData.angle) * dust.userData.radius;
        dust.rotation.z += delta * 0.5;
      });

      // Animate sparks with flicker
      sparkParticles.forEach(spark => {
        spark.userData.angle += delta * spark.userData.speed;
        const wobble = Math.sin(elapsed * spark.userData.flickerSpeed + spark.userData.phase) * 20;
        const r = spark.userData.baseRadius + wobble;
        spark.position.x = Math.cos(spark.userData.angle) * r;
        spark.position.y = Math.sin(spark.userData.angle) * r;
      });

      // Animate energy waves
      energyWaves.forEach((wave, i) => {
        const pulse = Math.sin(elapsed * 2 + wave.userData.phase);
        wave.scale.setScalar(1 + pulse * 0.1);
      });

      // Update center glow shader
      centerGlowMat.uniforms.time.value = elapsed;

      // Flicker portal light
      if (portalLight.intensity > 0) {
        const base = portalLight.userData?.baseIntensity || portalLight.intensity;
        portalLight.intensity = base * (0.85 + 0.15 * Math.sin(elapsed * 5));
      }

      renderer.render(scene, cam);
    };
    animate();

    // ============================================
    // GSAP SCROLL TIMELINE
    // ============================================
    gsap.registerPlugin(ScrollTrigger);

    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: containerRef.current,
        start: 'top top',
        end: '+=800%',
        scrub: 2,
        pin: true,
        anticipatePin: 1,
        onUpdate: (self) => setScrollProgress(self.progress)
      }
    });

    tl
      // ========== PHASE 1: Initial parallax (0-8%) ==========
      .to(bgImageRef.current, {
        scale: 1.1,
        duration: 1,
        ease: 'none'
      })
      
      // ========== PHASE 2: ZOOM TO MAN - Shows monolith + man + space above (8-22%) ==========
      // ZOOM CONTROL: scale 2.2 focuses on man at bottom-right while keeping monolith visible
      .to(bgImageRef.current, {
        scale: 2.2, // ZOOM LEVEL - adjust this to change zoom amount
        y: '-25%',  // Shifts view down to show base area
        x: '-8%',    // Shifts right to center on man
        duration: 2,
        ease: 'power2.inOut'
      }, '+=0.1')
      
      .to(textBottomLeftRef.current, {
        x: '45vw',
        y: '-20vh',
        duration: 2,
        ease: 'power2.inOut'
      }, '<')
      
      .to(textBottomCenterRef.current, {
        x: '-35vw',
        y: '5vh',
        duration: 2,
        ease: 'power2.inOut'
      }, '<')
      
      .to([line1Ref.current, line2Ref.current], {
        scaleX: 0,
        opacity: 0,
        duration: 1.2,
        ease: 'power2.inOut'
      }, '<0.3')
      
      // ========== PHASE 3: Hold zoom, matrix letters fade in (22-35%) ==========
      .to([textBottomLeftRef.current, textBottomCenterRef.current], {
        opacity: 0,
        duration: 0.8,
        ease: 'power2.out'
      })
      
      // Start matrix scrolling
      .call(() => { matrixScrolling = true; })
      
      // Fade in matrix characters
      .to(allMatrixChars.map(c => c.material), {
        opacity: 0.9,
        duration: 2,
        stagger: 0.01,
        ease: 'power2.out',
        onStart: () => {
          allMatrixChars.forEach(c => {
            c.material.userData = { baseOpacity: 1 };
          });
        }
      })
      
      // Camera moves closer slightly
      .to(cam.position, {
        z: 800,
        duration: 2,
        ease: 'power2.inOut'
      }, '<')
      
      // ========== PHASE 4: Matrix scrolls, hold (35-45%) ==========
      .to(bgImageRef.current, {
        scale: 2.4,
        duration: 1.5,
        ease: 'power2.inOut'
      })
      
      .to(cam.position, {
        z: 650,
        duration: 1.5,
        ease: 'power2.inOut'
      }, '<')
      
      // ========== PHASE 5: Letters fly to portal position (45-58%) ==========
      .call(() => { charsFlying = true; })
      
      // Letters fly from monolith to portal position (right side where man is)
      .to(allMatrixChars.map(c => c.position), {
        x: (i) => {
          const char = allMatrixChars[i];
          // Convert portal local position to matrix group local position
          const worldEnd = char.userData.endPos.clone();
          // Account for portal group offset from matrix group
          const offsetX = portalGroup.position.x - matrixGroup.position.x;
          const offsetY = portalGroup.position.y - matrixGroup.position.y;
          return worldEnd.x + offsetX;
        },
        y: (i) => {
          const char = allMatrixChars[i];
          const worldEnd = char.userData.endPos.clone();
          const offsetY = portalGroup.position.y - matrixGroup.position.y;
          return worldEnd.y + offsetY;
        },
        z: (i) => {
          const char = allMatrixChars[i];
          return char.userData.endPos.z + (portalGroup.position.z - matrixGroup.position.z);
        },
        duration: 3,
        stagger: {
          each: 0.015,
          from: "random"
        },
        ease: 'power3.inOut'
      })
      
      // Background fades as letters fly
      .to(bgImageRef.current, {
        opacity: 0.5,
        duration: 2,
        ease: 'power2.out'
      }, '<1')
      
      // Portal ring appears
      .to(ringMaterial, {
        opacity: 1,
        duration: 1.5,
        ease: 'power2.out'
      }, '-=1.5')
      
      .to(glowRingMat, {
        opacity: 0.5,
        duration: 1.5,
        ease: 'power2.out'
      }, '<')
      
      .to(portalLight, {
        intensity: 25,
        duration: 1.5,
        ease: 'power2.out',
        onUpdate: function() {
          portalLight.userData = { baseIntensity: portalLight.intensity };
        }
      }, '<')
      
      // ========== PHASE 6: Portal fully formed (58-68%) ==========
      .to(dustParticles.map(p => p.material), {
        opacity: 0.5,
        duration: 1.5,
        stagger: 0.008,
        ease: 'power2.out'
      }, '-=1')
      
      .to(sparkParticles.map(p => p.material), {
        opacity: 0.8,
        duration: 1,
        stagger: 0.008,
        ease: 'power2.out'
      }, '<0.3')
      
      .to(energyWaves.map(w => w.material), {
        opacity: 0.3,
        duration: 1,
        ease: 'power2.out'
      }, '<')
      
      // Center glow (white light filling portal)
      .to(centerGlowMat.uniforms.opacity, {
        value: 1,
        duration: 1.5,
        ease: 'power2.out'
      }, '<')
      
      .to(centerLight, {
        intensity: 12,
        duration: 1.5,
        ease: 'power2.out'
      }, '<')
      
      // Fade matrix chars into ring
      .to(allMatrixChars.map(c => c.material), {
        opacity: 0,
        duration: 1,
        ease: 'power2.out'
      }, '-=0.5')
      
      // ========== PHASE 7: Camera moves toward portal (68-78%) ==========
      // Move camera toward portal position
      .to(cam.position, {
        x: portalGroup.position.x * 0.3,
        y: portalGroup.position.y * 0.3,
        z: 400,
        duration: 2.5,
        ease: 'power2.inOut'
      })
      
      // ========== PHASE 8: Enter portal - zoom into white light (78-88%) ==========
      .to(cam.position, {
        x: portalGroup.position.x * 0.8,
        y: portalGroup.position.y * 0.8,
        z: portalGroup.position.z + 100,
        duration: 2,
        ease: 'power2.in'
      })
      
      // White overlay builds
      .to(whiteOverlayRef.current, {
        opacity: 1,
        duration: 2,
        ease: 'power2.in'
      }, '<')
      
      // Portal fades behind white
      .to([ringMaterial, glowRingMat], {
        opacity: 0,
        duration: 1.5,
        ease: 'power2.out'
      }, '<0.5')
      
      .to(dustParticles.map(p => p.material), {
        opacity: 0,
        duration: 1,
        ease: 'power2.out'
      }, '<')
      
      .to(sparkParticles.map(p => p.material), {
        opacity: 0,
        duration: 1,
        ease: 'power2.out'
      }, '<')
      
      .to(energyWaves.map(w => w.material), {
        opacity: 0,
        duration: 1,
        ease: 'power2.out'
      }, '<')
      
      .to(centerGlowMat.uniforms.opacity, {
        value: 0,
        duration: 1,
        ease: 'power2.out'
      }, '<')
      
      .to([portalLight, centerLight], {
        intensity: 0,
        duration: 1,
        ease: 'power2.out'
      }, '<')
      
      // ========== PHASE 9: Eyes adjust - white fades to reveal about (88-95%) ==========
      // About section appears behind white
      .set(aboutMaterial, { opacity: 1 })
      .set(aboutMesh.position, { z: -600 })
      
      // White fades down slowly (eyes adjusting)
      .to(whiteOverlayRef.current, {
        opacity: 0,
        duration: 3,
        ease: 'power3.out'
      })
      
      // // Camera positions for about section
      // .to(cam.position, {
      //   x: portalGroup.position.x,
      //   y: portalGroup.position.y,
      //   z:100,
      //   duration: 3,
      //   ease: 'power2.out'
      // }, '<')
      
      // About section comes forward
      // .to(aboutMesh.position, {
      //   z: -500,
      //   duration: 3,
      //   ease: 'power2.out'
      // }, '<')
      
      // ========== PHASE 10: About fills viewport (95-100%) ==========
      // .to(cam.position, {
      //   x: aboutMesh.position.x,
      //   y: aboutMesh.position.y,
      //   z: finalCamZ,
      //   duration: 2,
      //   ease: 'power1.out'
      // })
      
      // .to(aboutMesh.position, {
      //   z: finalAboutZ,
      //   duration: 2,
      //   ease: 'power1.out'
      // }, '<');

    // ============================================
    // RESIZE
    // ============================================
    const handleResize = () => {
      cam.aspect = window.innerWidth / window.innerHeight;
      cam.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      const newHeight = 2 * Math.tan(vFov / 2) * targetDistance;
      const newWidth = newHeight * (window.innerWidth / window.innerHeight);
      aboutMesh.geometry.dispose();
      aboutMesh.geometry = new THREE.PlaneBufferGeometry(newWidth, newHeight);
    };
    window.addEventListener('resize', handleResize);

    // ============================================
    // CLEANUP
    // ============================================
    return () => {
      window.removeEventListener('resize', handleResize);
      cancelAnimationFrame(animationId);
      lenis.destroy();
      ScrollTrigger.getAll().forEach(t => t.kill());
      renderer.dispose();
    };
  }, []);

  return (
    <div 
      ref={containerRef} 
      style={{ 
        height: '100vh', 
        width: '100vw',
        position: 'relative', 
        overflow: 'hidden',
        backgroundColor: '#000'
      }}
    >
      {/* Background Image */}
      <div 
        ref={bgImageRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          transformOrigin: 'center 80%', // Focus point: bottom area where man stands
          willChange: 'transform, opacity'
        }}
      >
        <img 
          src="monolith.jpg"
          alt="Monolith"
          style={{
            width: '100%',
            height: '100%',
            objectFit: 'cover',
            objectPosition: 'center 70%'
          }}
        />
      </div>

      {/* Text Bottom Left */}
      <div
        ref={textBottomLeftRef}
        style={{
          position: 'absolute',
          bottom: '12%',
          left: '6%',
          color: '#c8e6d8',
          fontSize: 'clamp(11px, 1.3vw, 16px)',
          fontFamily: "'Courier New', monospace",
          textShadow: '0 0 20px rgba(61, 166, 122, 0.6)',
          maxWidth: '320px',
          lineHeight: 1.7,
          zIndex: 10,
          willChange: 'transform, opacity'
        }}
      >
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore.
      </div>

      {/* Center Text with Lines */}
      <div style={{ position: 'absolute', bottom: '8%', left: 0, right: 0, zIndex: 10 }}>
        <div
          ref={line1Ref}
          style={{
            position: 'absolute',
            left: '6%',
            top: '50%',
            width: '40%',
            height: '1px',
            background: 'linear-gradient(to right, transparent, rgba(61, 166, 122, 0.7))',
            transformOrigin: 'left center',
            boxShadow: '0 0 8px rgba(61, 166, 122, 0.5)'
          }}
        />
        
        <div
          ref={textBottomCenterRef}
          style={{
            position: 'absolute',
            left: '50%',
            transform: 'translateX(-50%)',
            color: '#5fcf9f',
            fontSize: 'clamp(12px, 1.8vw, 22px)',
            fontFamily: "'Courier New', monospace",
            textShadow: '0 0 25px rgba(61, 166, 122, 0.8)',
            whiteSpace: 'nowrap',
            fontWeight: 'bold',
            letterSpacing: '3px',
            willChange: 'transform, opacity'
          }}
        >
          VIVAMUS SAGITTIS LACUS
        </div>
        
        <div
          ref={line2Ref}
          style={{
            position: 'absolute',
            right: '6%',
            top: '50%',
            width: '40%',
            height: '1px',
            background: 'linear-gradient(to left, transparent, rgba(61, 166, 122, 0.7))',
            transformOrigin: 'right center',
            boxShadow: '0 0 8px rgba(61, 166, 122, 0.5)'
          }}
        />
      </div>

      {/* Three.js Canvas */}
      <canvas
        ref={canvasRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          pointerEvents: 'none',
          zIndex: 20
        }}
      />

      {/* White Overlay for Tunnel Exit Effect */}
      <div
        ref={whiteOverlayRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          background: '#ffffff',
          opacity: 0,
          pointerEvents: 'none',
          zIndex: 25
        }}
      />

      {/* Vignette */}
      <div 
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          background: 'radial-gradient(ellipse at center 65%, transparent 20%, rgba(5, 15, 10, 0.8) 100%)',
          pointerEvents: 'none',
          zIndex: 15,
          opacity: scrollProgress < 0.7 ? 1 : 0,
          transition: 'opacity 1s ease-out'
        }} 
      />

      {/* Scroll Indicator */}
      {scrollProgress < 0.03 && (
        <div 
          style={{
            position: 'absolute',
            bottom: '3%',
            right: '4%',
            color: '#5fcf9f',
            fontSize: '12px',
            fontFamily: "'Courier New', monospace",
            textShadow: '0 0 12px rgba(61, 166, 122, 0.8)',
            zIndex: 30,
            animation: 'pulseIndicator 2s ease-in-out infinite',
            letterSpacing: '2px'
          }}
        >
          ▼ SCROLL TO ENTER ▼
        </div>
      )}

      {/* Progress Bar */}
      <div 
        style={{
          position: 'fixed',
          top: '50%',
          right: '12px',
          transform: 'translateY(-50%)',
          width: '2px',
          height: '60px',
          background: 'rgba(61, 166, 122, 0.15)',
          borderRadius: '1px',
          zIndex: 100
        }}
      >
        <div 
          style={{
            width: '100%',
            height: `${scrollProgress * 100}%`,
            background: 'linear-gradient(to bottom, #3da67a, #5fcf9f)',
            borderRadius: '1px',
            boxShadow: '0 0 6px rgba(61, 166, 122, 0.8)',
            transition: 'height 0.15s ease-out'
          }}
        />
      </div>
    </div>
  );
};

ReactDOM.createRoot(document.getElementById('root')).render(<MonolithPortal />);
</script>
</body>
</html>