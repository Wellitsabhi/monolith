<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Monolith Portal - Complete Experience</title>
<style>
* { 
  margin: 0; 
  padding: 0; 
  box-sizing: border-box; 
}

body { 
  font-family: 'Courier New', monospace; 
  background: #000; 
  color: #fff; 
  overflow-x: hidden;
  -webkit-font-smoothing: antialiased;
}

#root { 
  width: 100vw; 
  min-height: 100vh; 
}

::-webkit-scrollbar { 
  width: 8px; 
}

::-webkit-scrollbar-track { 
  background: #001a0f; 
}

::-webkit-scrollbar-thumb { 
  background: linear-gradient(to bottom, #00ff88, #00cc66);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #00ff88;
}
</style>
</head>
<body>
<div id="root"></div>

<!-- React, GSAP, Three.js -->
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js"></script>

<script type="text/babel">
const { useState, useEffect, useRef } = React;

// ============================================
// MAIN APP COMPONENT
// ============================================
const MonolithPortal = () => {
  // Refs for DOM elements
  const containerRef = useRef(null);
  const canvasRef = useRef(null);
  const textBottomLeftRef = useRef(null);
  const textBottomCenterRef = useRef(null);
  const line1Ref = useRef(null);
  const line2Ref = useRef(null);
  const bgImageRef = useRef(null);
  
  // State
  const [scrollProgress, setScrollProgress] = useState(0);
  const [isMobile, setIsMobile] = useState(false);

  // Check if mobile
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth <= 768);
    };
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  useEffect(() => {
    // ============================================
    // THREE.JS SETUP
    // ============================================
    const canvas = canvasRef.current;
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75, 
      window.innerWidth / window.innerHeight, 
      0.1, 
      1000
    );
    
    const renderer = new THREE.WebGLRenderer({ 
      canvas, 
      alpha: true,
      antialias: true,
      powerPreference: "high-performance"
    });
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    camera.position.z = 5;

    // ============================================
    // PORTAL GROUP - All 3D elements
    // ============================================
    const portalGroup = new THREE.Group();
    scene.add(portalGroup);

    // ============================================
    // MAIN PORTAL RING - Rotating torus
    // ============================================
    const ringGeometry = new THREE.TorusGeometry(2.2, 0.15, 16, 100);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ff88,
      transparent: true,
      opacity: 0,
      side: THREE.DoubleSide
    });
    const mainRing = new THREE.Mesh(ringGeometry, ringMaterial);
    portalGroup.add(mainRing);

    // ============================================
    // SECONDARY GLOW RING - Outer aura
    // ============================================
    const glowRingGeo = new THREE.TorusGeometry(2.5, 0.08, 12, 100);
    const glowRingMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0
    });
    const glowRing = new THREE.Mesh(glowRingGeo, glowRingMat);
    portalGroup.add(glowRing);

    // ============================================
    // PORTAL CENTER - Glowing disc with inverted gradient
    // Custom shader for depth effect
    // ============================================
    const portalDiscGeo = new THREE.CircleGeometry(2.0, 64);
    const portalDiscMat = new THREE.ShaderMaterial({
      transparent: true,
      side: THREE.DoubleSide,
      uniforms: {
        time: { value: 0 },
        opacity: { value: 0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform float opacity;
        varying vec2 vUv;
        
        void main() {
          vec2 center = vec2(0.5, 0.5);
          float dist = distance(vUv, center);
          
          // Inverted gradient - bright center, darker edges for DEPTH
          float gradient = smoothstep(0.5, 0.0, dist);
          
          // Pulsing glow effect
          float pulse = sin(time * 1.5) * 0.15 + 0.85;
          
          // White center to green-teal edges
          vec3 centerColor = vec3(1.0, 1.0, 1.0);
          vec3 edgeColor = vec3(0.0, 1.0, 0.7);
          vec3 color = mix(edgeColor, centerColor, gradient);
          
          // Add depth rings
          float rings = sin(dist * 20.0 - time * 2.0) * 0.1 + 0.9;
          
          float alpha = gradient * pulse * rings * opacity;
          gl_FragColor = vec4(color, alpha * 0.9);
        }
      `
    });
    const portalDisc = new THREE.Mesh(portalDiscGeo, portalDiscMat);
    portalDisc.position.z = -0.2;
    portalGroup.add(portalDisc);

    // ============================================
    // ENERGY WAVE RINGS - Multiple rotating layers
    // ============================================
    const energyRings = [];
    for (let i = 0; i < 6; i++) {
      const ringGeo = new THREE.TorusGeometry(
        2.2 + i * 0.25, 
        0.04, 
        8, 
        100
      );
      const ringMat = new THREE.MeshBasicMaterial({
        color: i % 2 === 0 ? 0x00ff88 : 0x66ffaa,
        transparent: true,
        opacity: 0
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      
      energyRings.push({
        mesh: ring,
        speed: 0.3 + i * 0.15,
        direction: i % 2 === 0 ? 1 : -1,
        phase: i * 0.5
      });
      
      portalGroup.add(ring);
    }

    // ============================================
    // MONOLITH TEXT PARTICLES
    // Vertical column of particles that emerge from monolith
    // These will form the portal ring
    // ============================================
    const textParticleCount = 3000;
    const textGeometry = new THREE.BufferGeometry();
    const textPositions = new Float32Array(textParticleCount * 3);
    const textTargets = new Float32Array(textParticleCount * 3);
    const textSizes = new Float32Array(textParticleCount);

    for (let i = 0; i < textParticleCount; i++) {
      const i3 = i * 3;
      
      // Starting position - VERTICAL LINE (monolith center)
      const verticalSpread = 0.05;
      textPositions[i3] = (Math.random() - 0.5) * verticalSpread;
      textPositions[i3 + 1] = (i / textParticleCount - 0.5) * 10;
      textPositions[i3 + 2] = (Math.random() - 0.5) * verticalSpread;
      
      // Target position - CIRCULAR RING (portal)
      const angle = (i / textParticleCount) * Math.PI * 4;
      const radiusVariation = 2.2 + (Math.random() - 0.5) * 0.3;
      textTargets[i3] = Math.cos(angle) * radiusVariation;
      textTargets[i3 + 1] = Math.sin(angle) * radiusVariation;
      textTargets[i3 + 2] = (Math.random() - 0.5) * 0.3;
      
      // Random particle sizes
      textSizes[i] = Math.random() * 2 + 1;
    }

    textGeometry.setAttribute('position', new THREE.BufferAttribute(textPositions, 3));
    textGeometry.setAttribute('target', new THREE.BufferAttribute(textTargets, 3));
    textGeometry.setAttribute('size', new THREE.BufferAttribute(textSizes, 1));

    // Shader for smooth particle transition
    const textParticleMat = new THREE.ShaderMaterial({
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      uniforms: {
        progress: { value: 0 },
        opacity: { value: 0 },
        time: { value: 0 }
      },
      vertexShader: `
        attribute vec3 target;
        attribute float size;
        uniform float progress;
        uniform float time;
        varying float vAlpha;
        varying float vProgress;
        
        void main() {
          // Smooth interpolation from vertical line to ring
          vec3 pos = mix(position, target, progress);
          
          // Add slight wave motion
          pos.x += sin(time + position.y * 2.0) * 0.05 * progress;
          pos.y += cos(time + position.x * 2.0) * 0.05 * progress;
          
          vAlpha = progress;
          vProgress = progress;
          
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_PointSize = size * (300.0 / -mvPosition.z) * (0.5 + progress * 0.5);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        uniform float opacity;
        uniform float time;
        varying float vAlpha;
        varying float vProgress;
        
        void main() {
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);
          if (dist > 0.5) discard;
          
          // Smooth circular particle
          float alpha = (1.0 - dist * 2.0) * vAlpha * opacity;
          
          // Color shift from white to green as they form ring
          vec3 startColor = vec3(0.8, 1.0, 0.9);
          vec3 endColor = vec3(0.0, 1.0, 0.7);
          vec3 color = mix(startColor, endColor, vProgress);
          
          // Slight sparkle
          float sparkle = sin(time * 5.0 + gl_FragCoord.x * 0.1) * 0.2 + 0.8;
          
          gl_FragColor = vec4(color * sparkle, alpha);
        }
      `
    });

    const textParticles = new THREE.Points(textGeometry, textParticleMat);
    portalGroup.add(textParticles);

    // ============================================
    // RING PARTICLES - Swirling around portal ring
    // ============================================
    const ringParticleCount = 1500;
    const ringParticleGeo = new THREE.BufferGeometry();
    const ringPositions = new Float32Array(ringParticleCount * 3);
    const ringVelocities = new Float32Array(ringParticleCount * 3);

    for (let i = 0; i < ringParticleCount; i++) {
      const i3 = i * 3;
      const angle = (i / ringParticleCount) * Math.PI * 2;
      const radius = 2.2 + Math.random() * 0.6;
      
      ringPositions[i3] = Math.cos(angle) * radius;
      ringPositions[i3 + 1] = Math.sin(angle) * radius;
      ringPositions[i3 + 2] = (Math.random() - 0.5) * 0.4;
      
      ringVelocities[i3] = (Math.random() - 0.5) * 0.01;
      ringVelocities[i3 + 1] = (Math.random() - 0.5) * 0.01;
      ringVelocities[i3 + 2] = (Math.random() - 0.5) * 0.005;
    }

    ringParticleGeo.setAttribute('position', new THREE.BufferAttribute(ringPositions, 3));

    const ringParticleMat = new THREE.PointsMaterial({
      color: 0x00ff88,
      size: 0.04,
      transparent: true,
      opacity: 0,
      blending: THREE.AdditiveBlending,
      sizeAttenuation: true
    });

    const ringParticles = new THREE.Points(ringParticleGeo, ringParticleMat);
    portalGroup.add(ringParticles);

    // ============================================
    // SPARKS - Random bright flashes
    // ============================================
    const sparkCount = 800;
    const sparkGeo = new THREE.BufferGeometry();
    const sparkPositions = new Float32Array(sparkCount * 3);
    const sparkPhases = new Float32Array(sparkCount);

    for (let i = 0; i < sparkCount; i++) {
      const i3 = i * 3;
      const angle = Math.random() * Math.PI * 2;
      const radius = 2.0 + Math.random() * 0.8;
      
      sparkPositions[i3] = Math.cos(angle) * radius;
      sparkPositions[i3 + 1] = Math.sin(angle) * radius;
      sparkPositions[i3 + 2] = (Math.random() - 0.5) * 0.3;
      
      sparkPhases[i] = Math.random() * Math.PI * 2;
    }

    sparkGeo.setAttribute('position', new THREE.BufferAttribute(sparkPositions, 3));
    sparkGeo.setAttribute('phase', new THREE.BufferAttribute(sparkPhases, 1));

    const sparkMat = new THREE.ShaderMaterial({
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      uniforms: {
        time: { value: 0 },
        opacity: { value: 0 }
      },
      vertexShader: `
        attribute float phase;
        uniform float time;
        varying float vAlpha;
        
        void main() {
          vAlpha = abs(sin(time * 3.0 + phase));
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = (3.0 + vAlpha * 2.0) * (300.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        uniform float opacity;
        varying float vAlpha;
        
        void main() {
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);
          if (dist > 0.5) discard;
          
          float alpha = (1.0 - dist * 2.0) * vAlpha * opacity;
          gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
        }
      `
    });

    const sparks = new THREE.Points(sparkGeo, sparkMat);
    portalGroup.add(sparks);

    // Start portal invisible and scaled down
    portalGroup.scale.set(0, 0, 0);

    // ============================================
    // ANIMATION LOOP
    // ============================================
    let time = 0;
    const animate = () => {
      requestAnimationFrame(animate);
      time += 0.016;

      // Update shader uniforms
      portalDiscMat.uniforms.time.value = time;
      textParticleMat.uniforms.time.value = time;
      sparkMat.uniforms.time.value = time;

      // Rotate main rings
      mainRing.rotation.z += 0.008;
      glowRing.rotation.z -= 0.012;

      // Animate energy rings with wave motion
      energyRings.forEach((ring, index) => {
        ring.mesh.rotation.z += ring.speed * 0.01 * ring.direction;
        
        // Pulsing scale
        const pulse = 1 + Math.sin(time * 1.5 + ring.phase) * 0.08;
        ring.mesh.scale.set(pulse, pulse, 1);
      });

      // Rotate ring particles
      const ringPos = ringParticles.geometry.attributes.position.array;
      for (let i = 0; i < ringParticleCount; i += 2) {
        const i3 = i * 3;
        const x = ringPos[i3];
        const y = ringPos[i3 + 1];
        const angle = Math.atan2(y, x) + 0.01;
        const radius = Math.sqrt(x * x + y * y);
        ringPos[i3] = Math.cos(angle) * radius;
        ringPos[i3 + 1] = Math.sin(angle) * radius;
      }
      ringParticles.geometry.attributes.position.needsUpdate = true;

      // Portal breathing effect when fully formed
      if (portalGroup.scale.x >= 0.98) {
        const breath = 1 + Math.sin(time * 0.8) * 0.03;
        portalGroup.scale.set(breath, breath, breath);
      }

      renderer.render(scene, camera);
    };
    animate();

    // ============================================
    // GSAP SCROLL TIMELINE
    // ============================================
    gsap.registerPlugin(ScrollTrigger);

    const timeline = gsap.timeline({
      scrollTrigger: {
        trigger: containerRef.current,
        start: 'top top',
        end: '+=600%',
        scrub: 2,
        pin: true,
        anticipatePin: 1,
        onUpdate: (self) => {
          setScrollProgress(self.progress);
        }
      }
    });

    // ============================================
    // FRAME 0 → FRAME 1 (0-33% scroll)
    // Initial view, slight parallax on background
    // Text stays in original position
    // ============================================
    timeline
      .to(bgImageRef.current, {
        scale: 1.1,
        duration: 2,
        ease: 'power1.out'
      })
      
    // ============================================
    // FRAME 1 → FRAME 2 (33-66% scroll)  
    // Zoom to bottom of monolith
    // Text animates to new positions:
    // - Bottom-left → Middle-right
    // - Bottom-center (with lines) → Bottom-left
    // ============================================
      .to(bgImageRef.current, {
        scale: 4.5,
        y: '-50%',
        duration: 3,
        ease: 'power2.inOut'
      }, '+=0.5')
      
      // Bottom-left text moves to middle-right
      .to(textBottomLeftRef.current, {
        x: isMobile ? '30vw' : '50vw',
        y: isMobile ? '-20vh' : '-15vh',
        fontSize: isMobile ? 'clamp(10px, 2.5vw, 18px)' : 'clamp(12px, 1.8vw, 22px)',
        duration: 3,
        ease: 'power2.inOut'
      }, '<')
      
      // Bottom-center text (with lines) moves to bottom-left
      .to(textBottomCenterRef.current, {
        x: isMobile ? '-35vw' : '-40vw',
        y: isMobile ? '5vh' : '8vh',
        fontSize: isMobile ? 'clamp(9px, 2vw, 16px)' : 'clamp(11px, 1.5vw, 20px)',
        duration: 3,
        ease: 'power2.inOut'
      }, '<')
      
      // Lines collapse
      .to([line1Ref.current, line2Ref.current], {
        scaleX: 0,
        opacity: 0,
        duration: 2,
        ease: 'power2.in'
      }, '<0.5')
      
    // ============================================
    // FRAME 2 → FRAME 3 (66-100% scroll)
    // Extreme zoom to monolith bottom
    // Text fades out
    // Vertical text particles emerge and form portal
    // ============================================
      .to(bgImageRef.current, {
        scale: 10,
        y: '-65%',
        duration: 4,
        ease: 'power2.inOut'
      }, '+=0.3')
      
      // Fade out all text
      .to([textBottomLeftRef.current, textBottomCenterRef.current], {
        opacity: 0,
        duration: 2,
        ease: 'power2.in'
      }, '<')
      
      // ============================================
      // PORTAL FORMATION SEQUENCE
      // ============================================
      
      // Text particles start appearing (vertical line)
      .to(textParticleMat.uniforms.opacity, {
        value: 1,
        duration: 1.5,
        ease: 'power2.out'
      }, '-=2')
      
      // Particles emerge from monolith and form ring
      .to(textParticleMat.uniforms.progress, {
        value: 1,
        duration: 4,
        ease: 'power3.inOut'
      }, '<0.5')
      
      // Portal group scales up
      .to(portalGroup.scale, {
        x: 1,
        y: 1,
        z: 1,
        duration: 3,
        ease: 'back.out(1.4)'
      }, '-=3')
      
      // Main portal elements fade in
      .to([ringMaterial, glowRingMat, portalDiscMat.uniforms.opacity], {
        opacity: 1,
        value: 1,
        duration: 2.5,
        ease: 'power2.out'
      }, '<0.5')
      
      // Energy rings appear with stagger
      .to(energyRings.map(r => r.mesh.material), {
        opacity: 0.4,
        duration: 2,
        stagger: 0.15,
        ease: 'power2.out'
      }, '<0.3')
      
      // Ring particles appear
      .to(ringParticleMat, {
        opacity: 0.8,
        duration: 2,
        ease: 'power2.out'
      }, '<0.2')
      
      // Sparks activate
      .to(sparkMat.uniforms.opacity, {
        value: 0.9,
        duration: 2,
        ease: 'power2.out'
      }, '<0.3');

    // ============================================
    // RESPONSIVE HANDLING
    // ============================================
    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', handleResize);

    // ============================================
    // CLEANUP
    // ============================================
    return () => {
      window.removeEventListener('resize', handleResize);
      ScrollTrigger.getAll().forEach(t => t.kill());
      renderer.dispose();
    };
  }, [isMobile]);

  // ============================================
  // RENDER
  // ============================================
  return (
    <div 
      ref={containerRef} 
      style={{ 
        height: '100vh', 
        width: '100vw',
        position: 'relative', 
        overflow: 'hidden',
        backgroundColor: '#000'
      }}
    >
      {/* ============================================ */}
      {/* STICKY BACKGROUND IMAGE */}
      {/* ============================================ */}
      <div 
        ref={bgImageRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          transformOrigin: 'center 70%',
          willChange: 'transform'
        }}
      >
        <img 
          src="monolith.jpg"
          alt="Monolith"
          style={{
            width: '100%',
            height: '100%',
            objectFit: 'cover',
            objectPosition: 'center 70%'
          }}
        />
      </div>

      {/* ============================================ */}
      {/* FRAME 0-1: BOTTOM LEFT TEXT */}
      {/* Animates to middle-right in Frame 2 */}
      {/* ============================================ */}
      <div
        ref={textBottomLeftRef}
        style={{
          position: 'absolute',
          bottom: isMobile ? '18%' : '15%',
          left: isMobile ? '5%' : '8%',
          color: '#ffffff',
          fontSize: isMobile ? 'clamp(10px, 2.2vw, 16px)' : 'clamp(12px, 1.5vw, 18px)',
          fontFamily: "'Courier New', monospace",
          textShadow: '0 0 20px rgba(0, 255, 136, 0.6), 0 0 40px rgba(0, 255, 136, 0.3)',
          maxWidth: isMobile ? '60%' : '350px',
          lineHeight: 1.6,
          zIndex: 10,
          letterSpacing: '0.5px',
          willChange: 'transform, opacity'
        }}
      >
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore.
      </div>

      {/* ============================================ */}
      {/* FRAME 0-1: BOTTOM CENTER TEXT WITH LINES */}
      {/* Animates to bottom-left in Frame 2 */}
      {/* ============================================ */}
      <div style={{ 
        position: 'absolute', 
        bottom: isMobile ? '8%' : '10%', 
        left: 0, 
        right: 0, 
        zIndex: 10 
      }}>
        {/* Left decorative line */}
        <div
          ref={line1Ref}
          style={{
            position: 'absolute',
            left: isMobile ? '5%' : '8%',
            top: '50%',
            width: isMobile ? '30%' : '38%',
            height: '2px',
            background: 'linear-gradient(to right, transparent, rgba(0, 255, 136, 0.8))',
            transformOrigin: 'left center',
            boxShadow: '0 0 10px rgba(0, 255, 136, 0.6)',
            willChange: 'transform'
          }}
        />
        
        {/* Center text */}
        <div
          ref={textBottomCenterRef}
          style={{
            position: 'absolute',
            left: '50%',
            transform: 'translateX(-50%)',
            color: '#00ff88',
            fontSize: isMobile ? 'clamp(11px, 3vw, 20px)' : 'clamp(14px, 2vw, 24px)',
            fontFamily: "'Courier New', monospace",
            textShadow: '0 0 25px rgba(0, 255, 136, 0.8), 0 0 50px rgba(0, 255, 136, 0.4)',
            whiteSpace: 'nowrap',
            fontWeight: 'bold',
            letterSpacing: isMobile ? '1px' : '2px',
            willChange: 'transform, opacity'
          }}
        >
          VIVAMUS SAGITTIS LACUS
        </div>
        
        {/* Right decorative line */}
        <div
          ref={line2Ref}
          style={{
            position: 'absolute',
            right: isMobile ? '5%' : '8%',
            top: '50%',
            width: isMobile ? '30%' : '38%',
            height: '2px',
            background: 'linear-gradient(to left, transparent, rgba(0, 255, 136, 0.8))',
            transformOrigin: 'right center',
            boxShadow: '0 0 10px rgba(0, 255, 136, 0.6)',
            willChange: 'transform'
          }}
        />
      </div>

      {/* ============================================ */}
      {/* THREE.JS CANVAS - Portal rendering */}
      {/* ============================================ */}
      <canvas
        ref={canvasRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          pointerEvents: 'none',
          zIndex: 20,
          opacity: scrollProgress > 0.65 ? 1 : 0,
          transition: 'opacity 0.8s ease-out'
        }}
      />

      {/* ============================================ */}
      {/* VIGNETTE OVERLAY - Atmospheric depth */}
      {/* ============================================ */}
      <div 
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          background: 'radial-gradient(ellipse at center 65%, transparent 25%, rgba(0, 20, 10, 0.7) 100%)',
          pointerEvents: 'none',
          zIndex: 5
        }} 
      />

      {/* ============================================ */}
      {/* SCROLL INDICATOR */}
      {/* ============================================ */}
      {scrollProgress < 0.05 && (
        <div 
          style={{
            position: 'absolute',
            bottom: '4%',
            right: '5%',
            color: '#00ff88',
            fontSize: isMobile ? '11px' : '13px',
            fontFamily: "'Courier New', monospace",
            textShadow: '0 0 15px rgba(0, 255, 136, 0.8)',
            zIndex: 30,
            animation: 'pulseIndicator 2s ease-in-out infinite',
            letterSpacing: '2px'
          }}
        >
          ▼ SCROLL TO ENTER ▼
        </div>
      )}

      {/* ============================================ */}
      {/* ANIMATIONS */}
      {/* ============================================ */}
      <style>{`
        @keyframes pulseIndicator {
          0%, 100% { 
            opacity: 0.4; 
            transform: translateY(0); 
          }
          50% { 
            opacity: 1; 
            transform: translateY(-6px); 
          }
        }
      `}</style>
    </div>
  );
};

// ============================================
// MOUNT APP
// ============================================
ReactDOM.createRoot(document.getElementById('root')).render(<MonolithPortal />);
</script>
</body>
</html>