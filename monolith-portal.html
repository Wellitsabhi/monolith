<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Monolith Portal</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

html.lenis, html.lenis body { height: auto; }
.lenis.lenis-smooth { scroll-behavior: auto !important; }

body { 
  font-family: 'Courier New', monospace; 
  background: #000; 
  color: #fff; 
  overflow-x: hidden;
}

#root { width: 100vw; min-height: 100vh; }

::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: #0a1a10; }
::-webkit-scrollbar-thumb { background: #2a8a5a; border-radius: 2px; }

@keyframes pulseIndicator {
  0%, 100% { opacity: 0.3; transform: translateY(0); }
  50% { opacity: 1; transform: translateY(-5px); }
}
</style>
</head>
<body>
<div id="root"></div>

<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/lenis@1.1.13/dist/lenis.min.js"></script>
<script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js"></script>

<script type="text/babel">
const { useState, useEffect, useRef } = React;

const MonolithPortal = () => {
  const containerRef = useRef(null);
  const canvasRef = useRef(null);
  const textBottomLeftRef = useRef(null);
  const textBottomCenterRef = useRef(null);
  const line1Ref = useRef(null);
  const line2Ref = useRef(null);
  const bgImageRef = useRef(null);
  
  const [scrollProgress, setScrollProgress] = useState(0);

  useEffect(() => {
    // ============================================
    // LENIS SMOOTH SCROLL
    // ============================================
    const lenis = new Lenis({
      duration: 1.4,
      easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
      smoothWheel: true,
      wheelMultiplier: 0.8,
    });

    lenis.on('scroll', ScrollTrigger.update);
    gsap.ticker.add((time) => lenis.raf(time * 1000));
    gsap.ticker.lagSmoothing(0);

    // ============================================
    // COLOR PALETTE - HYDRA DARK GREEN
    // ============================================
    const colors = {
      primary: 0x3da67a,      // Atmospheric green
      glow: 0x5fcf9f,         // Lighter glow
      dark: 0x1a4a35,         // Dark green
      white: 0xffffff,
      spark: 0x8fffcc
    };

    // ============================================
    // THREE.JS SETUP
    // ============================================
    const canvas = canvasRef.current;
    const scene = new THREE.Scene();
    
    const cam = new THREE.PerspectiveCamera(
      75, 
      window.innerWidth / window.innerHeight, 
      1, 
      10000
    );
    cam.position.z = 1000;
    scene.add(cam);
    
    const renderer = new THREE.WebGLRenderer({ 
      canvas, 
      alpha: true,
      antialias: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // ============================================
    // LIGHTING
    // ============================================
    const ambientLight = new THREE.AmbientLight(0x1a3a2a, 0.3);
    scene.add(ambientLight);

    const portalLight = new THREE.PointLight(colors.glow, 0, 800, 1.5);
    portalLight.position.set(0, 0, 100);
    scene.add(portalLight);

    const centerLight = new THREE.PointLight(0xffffff, 0, 400, 2);
    centerLight.position.set(0, 0, 50);
    scene.add(centerLight);

    // ============================================
    // TEXTURES
    // ============================================
    const createSmokeTexture = () => {
      const c = document.createElement('canvas');
      c.width = 128;
      c.height = 128;
      const ctx = c.getContext('2d');
      const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
      gradient.addColorStop(0.3, 'rgba(200, 255, 230, 0.3)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 128, 128);
      return new THREE.CanvasTexture(c);
    };

    const createSparkTexture = () => {
      const c = document.createElement('canvas');
      c.width = 32;
      c.height = 32;
      const ctx = c.getContext('2d');
      const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
      gradient.addColorStop(0.2, 'rgba(180, 255, 220, 0.8)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 32, 32);
      return new THREE.CanvasTexture(c);
    };

    const smokeTexture = createSmokeTexture();
    const sparkTexture = createSparkTexture();

    // ============================================
    // PORTAL GROUP
    // ============================================
    const portalGroup = new THREE.Group();
    portalGroup.position.z = 50;
    scene.add(portalGroup);

    // ============================================
    // PORTAL RING (TORUS)
    // ============================================
    const ringGeometry = new THREE.TorusBufferGeometry(200, 12, 16, 100);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: colors.primary,
      transparent: true,
      opacity: 0
    });
    const portalRing = new THREE.Mesh(ringGeometry, ringMaterial);
    portalGroup.add(portalRing);

    // Outer glow ring
    const glowRingGeo = new THREE.TorusBufferGeometry(200, 30, 16, 100);
    const glowRingMat = new THREE.MeshBasicMaterial({
      color: colors.glow,
      transparent: true,
      opacity: 0,
      blending: THREE.AdditiveBlending
    });
    const glowRing = new THREE.Mesh(glowRingGeo, glowRingMat);
    portalGroup.add(glowRing);

    // ============================================
    // CENTER GLOW (WHITE DEPTH)
    // ============================================
    const centerGlowGeo = new THREE.CircleBufferGeometry(180, 64);
    const centerGlowMat = new THREE.ShaderMaterial({
      transparent: true,
      blending: THREE.AdditiveBlending,
      uniforms: {
        opacity: { value: 0 },
        time: { value: 0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float opacity;
        uniform float time;
        varying vec2 vUv;
        
        void main() {
          float dist = length(vUv - vec2(0.5)) * 2.0;
          
          // Inverted gradient - white center fading to transparent
          float glow = 1.0 - smoothstep(0.0, 0.8, dist);
          glow = pow(glow, 1.5);
          
          // Subtle pulse
          glow *= 0.8 + 0.2 * sin(time * 2.0);
          
          // White to green gradient
          vec3 color = mix(vec3(1.0), vec3(0.4, 0.9, 0.7), dist * 0.5);
          
          gl_FragColor = vec4(color, glow * opacity);
        }
      `
    });
    const centerGlow = new THREE.Mesh(centerGlowGeo, centerGlowMat);
    centerGlow.position.z = -10;
    portalGroup.add(centerGlow);

    // ============================================
    // DUST/CLOUD PARTICLES AROUND RING
    // ============================================
    const dustParticles = [];
    const dustGeo = new THREE.PlaneBufferGeometry(80, 80);
    
    for (let i = 0; i < 150; i++) {
      const dustMat = new THREE.MeshBasicMaterial({
        map: smokeTexture,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      const dust = new THREE.Mesh(dustGeo, dustMat);
      
      // Position around the ring
      const angle = Math.random() * Math.PI * 2;
      const radius = 180 + Math.random() * 80;
      const zOffset = (Math.random() - 0.5) * 60;
      
      dust.position.set(
        Math.cos(angle) * radius,
        Math.sin(angle) * radius,
        zOffset
      );
      dust.rotation.z = Math.random() * Math.PI * 2;
      dust.userData = { 
        angle, 
        radius, 
        speed: 0.2 + Math.random() * 0.3,
        zOffset 
      };
      
      dustParticles.push(dust);
      portalGroup.add(dust);
    }

    // ============================================
    // SPARK PARTICLES
    // ============================================
    const sparkParticles = [];
    const sparkGeo = new THREE.PlaneBufferGeometry(8, 8);
    
    for (let i = 0; i < 80; i++) {
      const sparkMat = new THREE.MeshBasicMaterial({
        map: sparkTexture,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      const spark = new THREE.Mesh(sparkGeo, sparkMat);
      
      const angle = Math.random() * Math.PI * 2;
      const radius = 160 + Math.random() * 100;
      
      spark.position.set(
        Math.cos(angle) * radius,
        Math.sin(angle) * radius,
        (Math.random() - 0.5) * 40
      );
      
      spark.userData = {
        angle,
        baseRadius: radius,
        speed: 0.5 + Math.random() * 0.5,
        flickerSpeed: 5 + Math.random() * 10,
        phase: Math.random() * Math.PI * 2
      };
      
      sparkParticles.push(spark);
      portalGroup.add(spark);
    }

    // ============================================
    // ENERGY WAVES
    // ============================================
    const energyWaves = [];
    for (let i = 0; i < 3; i++) {
      const waveGeo = new THREE.RingBufferGeometry(195, 210, 64);
      const waveMat = new THREE.MeshBasicMaterial({
        color: colors.glow,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide
      });
      const wave = new THREE.Mesh(waveGeo, waveMat);
      wave.userData = { phase: i * (Math.PI * 2 / 3) };
      energyWaves.push(wave);
      portalGroup.add(wave);
    }

    // ============================================
    // MONOLITH PARTICLES (dots that form portal)
    // ============================================
    const monolithParticles = [];
    const particleCount = 500;
    const particleGeo = new THREE.PlaneBufferGeometry(4, 4);
    
    for (let i = 0; i < particleCount; i++) {
      const pMat = new THREE.MeshBasicMaterial({
        map: sparkTexture,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      const particle = new THREE.Mesh(particleGeo, pMat);
      
      // Start position: vertical line (monolith dots)
      const startY = (Math.random() - 0.5) * 600;
      const startX = (Math.random() - 0.5) * 20;
      const startZ = 200 + Math.random() * 50;
      
      // End position: on the portal ring
      const endAngle = Math.random() * Math.PI * 2;
      const endRadius = 180 + Math.random() * 40;
      const endX = Math.cos(endAngle) * endRadius;
      const endY = Math.sin(endAngle) * endRadius;
      const endZ = (Math.random() - 0.5) * 30;
      
      particle.position.set(startX, startY, startZ);
      particle.userData = {
        startPos: new THREE.Vector3(startX, startY, startZ),
        endPos: new THREE.Vector3(endX, endY, endZ),
        delay: Math.random() * 0.5,
        speed: 0.8 + Math.random() * 0.4
      };
      
      monolithParticles.push(particle);
      scene.add(particle);
    }

    // ============================================
    // FLASH PLANE
    // ============================================
    const flashGeo = new THREE.PlaneBufferGeometry(2000, 2000);
    const flashMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0,
      blending: THREE.AdditiveBlending
    });
    const flashPlane = new THREE.Mesh(flashGeo, flashMat);
    flashPlane.position.z = 300;
    scene.add(flashPlane);

    // ============================================
    // 3D ABOUT SECTION
    // ============================================
    const createAboutTexture = () => {
      const c = document.createElement('canvas');
      c.width = 1920;
      c.height = 1080;
      const ctx = c.getContext('2d');
      
      // Background - dark atmospheric
      const grad = ctx.createLinearGradient(0, 0, 0, 1080);
      grad.addColorStop(0, '#0a1f15');
      grad.addColorStop(0.5, '#051210');
      grad.addColorStop(1, '#020a08');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 1920, 1080);
      
      // Subtle grid
      ctx.strokeStyle = 'rgba(61, 166, 122, 0.06)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 1920; i += 60) {
        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, 1080); ctx.stroke();
      }
      for (let i = 0; i < 1080; i += 60) {
        ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(1920, i); ctx.stroke();
      }
      
      // Title
      ctx.shadowBlur = 50;
      ctx.shadowColor = 'rgba(61, 166, 122, 0.8)';
      ctx.fillStyle = '#5fcf9f';
      ctx.font = 'bold 72px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('ABOUT THE MONOLITH', 960, 150);
      
      // Subtitle
      ctx.shadowBlur = 20;
      ctx.font = '24px Courier New';
      ctx.fillStyle = 'rgba(95, 207, 159, 0.7)';
      ctx.fillText('Beyond the Portal • Another Dimension', 960, 200);
      
      // Divider
      ctx.shadowBlur = 15;
      const lineGrad = ctx.createLinearGradient(300, 0, 1620, 0);
      lineGrad.addColorStop(0, 'transparent');
      lineGrad.addColorStop(0.2, '#3da67a');
      lineGrad.addColorStop(0.8, '#3da67a');
      lineGrad.addColorStop(1, 'transparent');
      ctx.strokeStyle = lineGrad;
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(300, 240); ctx.lineTo(1620, 240); ctx.stroke();
      
      // Body text
      ctx.shadowBlur = 0;
      ctx.textAlign = 'left';
      ctx.fillStyle = '#aaccbb';
      ctx.font = '22px Courier New';
      
      const paragraphs = [
        'Lorem ipsum dolor sit amet, consectetur adipiscing elit.',
        'Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.',
        'Ut enim ad minim veniam, quis nostrud exercitation ullamco.',
        '',
        'Duis aute irure dolor in reprehenderit in voluptate velit esse.',
        'Excepteur sint occaecat cupidatat non proident, sunt in culpa.',
      ];
      paragraphs.forEach((t, i) => ctx.fillText(t, 200, 310 + i * 38));
      
      // Feature boxes
      ctx.shadowBlur = 15;
      ctx.shadowColor = 'rgba(61, 166, 122, 0.4)';
      ctx.strokeStyle = 'rgba(61, 166, 122, 0.5)';
      ctx.lineWidth = 2;
      
      // Box 1
      ctx.strokeRect(200, 550, 450, 200);
      ctx.fillStyle = 'rgba(61, 166, 122, 0.08)';
      ctx.fillRect(200, 550, 450, 200);
      ctx.shadowBlur = 25;
      ctx.fillStyle = '#5fcf9f';
      ctx.font = 'bold 28px Courier New';
      ctx.fillText('Dimension Alpha', 240, 610);
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#8ab8a0';
      ctx.font = '18px Courier New';
      ctx.fillText('The first realm beyond the portal.', 240, 660);
      ctx.fillText('Reality bends to consciousness.', 240, 690);
      ctx.fillText('Time flows differently here.', 240, 720);
      
      // Box 2
      ctx.shadowBlur = 15;
      ctx.strokeRect(720, 550, 450, 200);
      ctx.fillStyle = 'rgba(61, 166, 122, 0.08)';
      ctx.fillRect(720, 550, 450, 200);
      ctx.shadowBlur = 25;
      ctx.fillStyle = '#5fcf9f';
      ctx.font = 'bold 28px Courier New';
      ctx.fillText('Quantum Matrix', 760, 610);
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#8ab8a0';
      ctx.font = '18px Courier New';
      ctx.fillText('The structure connecting all.', 760, 660);
      ctx.fillText('Navigate infinite possibilities.', 760, 690);
      ctx.fillText('Parallel realities converge.', 760, 720);
      
      // Box 3
      ctx.shadowBlur = 15;
      ctx.strokeRect(1240, 550, 450, 200);
      ctx.fillStyle = 'rgba(61, 166, 122, 0.08)';
      ctx.fillRect(1240, 550, 450, 200);
      ctx.shadowBlur = 25;
      ctx.fillStyle = '#5fcf9f';
      ctx.font = 'bold 28px Courier New';
      ctx.fillText('Energy Nexus', 1280, 610);
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#8ab8a0';
      ctx.font = '18px Courier New';
      ctx.fillText('Pure dimensional energy flows.', 1280, 660);
      ctx.fillText('Harness the cosmic current.', 1280, 690);
      ctx.fillText('Become one with the void.', 1280, 720);
      
      // Welcome box
      ctx.shadowBlur = 30;
      ctx.shadowColor = 'rgba(61, 166, 122, 0.5)';
      ctx.strokeStyle = 'rgba(95, 207, 159, 0.6)';
      ctx.lineWidth = 3;
      ctx.strokeRect(200, 820, 1520, 140);
      const welcomeGrad = ctx.createLinearGradient(200, 820, 1720, 960);
      welcomeGrad.addColorStop(0, 'rgba(61, 166, 122, 0.15)');
      welcomeGrad.addColorStop(1, 'rgba(61, 166, 122, 0.03)');
      ctx.fillStyle = welcomeGrad;
      ctx.fillRect(200, 820, 1520, 140);
      
      ctx.shadowBlur = 40;
      ctx.fillStyle = '#5fcf9f';
      ctx.font = 'bold 36px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('Welcome to the Other Side', 960, 880);
      
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#8ab8a0';
      ctx.font = '20px Courier New';
      ctx.fillText('You have successfully traversed the dimensional portal. This is your destination.', 960, 925);
      
      // Footer
      ctx.fillStyle = 'rgba(95, 207, 159, 0.4)';
      ctx.font = '14px Courier New';
      ctx.fillText('━━━━━━━━━━  TRANSMISSION COMPLETE  ━━━━━━━━━━', 960, 1020);
      
      ctx.textAlign = 'left';
      ctx.fillStyle = '#445';
      ctx.fillText('Coordinates: Unknown', 200, 1050);
      ctx.fillText('Status: Stable', 700, 1050);
      ctx.fillText('Energy: Optimal', 1200, 1050);
      
      return new THREE.CanvasTexture(c);
    };

    const aboutTexture = createAboutTexture();
    
    // Calculate exact size to fill viewport
    const vFov = cam.fov * Math.PI / 180;
    const targetDistance = 800;
    const planeHeight = 2 * Math.tan(vFov / 2) * targetDistance;
    const planeWidth = planeHeight * (window.innerWidth / window.innerHeight);
    
    const aboutGeometry = new THREE.PlaneBufferGeometry(planeWidth, planeHeight);
    const aboutMaterial = new THREE.MeshBasicMaterial({
      map: aboutTexture,
      transparent: true,
      opacity: 0
    });
    
    const aboutMesh = new THREE.Mesh(aboutGeometry, aboutMaterial);
    aboutMesh.position.z = -2500;
    scene.add(aboutMesh);

    // Final positions
    const finalAboutZ = 200;
    const finalCamZ = finalAboutZ + targetDistance;

    // ============================================
    // ANIMATION LOOP
    // ============================================
    const clock = new THREE.Clock();
    let animationId;
    
    const animate = () => {
      animationId = requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const elapsed = clock.getElapsedTime();

      // Rotate portal group slowly
      portalGroup.rotation.z += delta * 0.15;

      // Animate dust particles around ring
      dustParticles.forEach(dust => {
        dust.userData.angle += delta * dust.userData.speed;
        dust.position.x = Math.cos(dust.userData.angle) * dust.userData.radius;
        dust.position.y = Math.sin(dust.userData.angle) * dust.userData.radius;
        dust.rotation.z += delta * 0.5;
      });

      // Animate sparks with flicker
      sparkParticles.forEach(spark => {
        spark.userData.angle += delta * spark.userData.speed;
        const wobble = Math.sin(elapsed * spark.userData.flickerSpeed + spark.userData.phase) * 20;
        const r = spark.userData.baseRadius + wobble;
        spark.position.x = Math.cos(spark.userData.angle) * r;
        spark.position.y = Math.sin(spark.userData.angle) * r;
        
        // Flicker opacity
        if (spark.material.opacity > 0) {
          spark.material.opacity = spark.material.opacity * (0.7 + 0.3 * Math.sin(elapsed * spark.userData.flickerSpeed));
        }
      });

      // Animate energy waves
      energyWaves.forEach((wave, i) => {
        const pulse = Math.sin(elapsed * 2 + wave.userData.phase);
        wave.scale.setScalar(1 + pulse * 0.1);
        if (wave.material.opacity > 0) {
          wave.material.opacity = wave.material.opacity * (0.3 + 0.7 * Math.abs(pulse));
        }
      });

      // Update center glow shader
      centerGlowMat.uniforms.time.value = elapsed;

      // Flicker portal light
      if (portalLight.intensity > 0) {
        portalLight.intensity = portalLight.intensity * (0.8 + 0.2 * Math.sin(elapsed * 5));
      }

      renderer.render(scene, cam);
    };
    animate();

    // ============================================
    // GSAP SCROLL TIMELINE
    // ============================================
    gsap.registerPlugin(ScrollTrigger);

    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: containerRef.current,
        start: 'top top',
        end: '+=600%',
        scrub: 2,
        pin: true,
        anticipatePin: 1,
        onUpdate: (self) => setScrollProgress(self.progress)
      }
    });

    tl
      // ========== PHASE 1: Parallax (0-10%) ==========
      .to(bgImageRef.current, {
        scale: 1.15,
        duration: 1,
        ease: 'none'
      })
      
      // ========== PHASE 2: Zoom to monolith base (10-30%) ==========
      .to(bgImageRef.current, {
        scale: 4,
        y: '-45%',
        duration: 2.5,
        ease: 'power2.inOut'
      }, '+=0.1')
      
      .to(textBottomLeftRef.current, {
        x: '45vw',
        y: '-20vh',
        duration: 2.5,
        ease: 'power2.inOut'
      }, '<')
      
      .to(textBottomCenterRef.current, {
        x: '-35vw',
        y: '5vh',
        duration: 2.5,
        ease: 'power2.inOut'
      }, '<')
      
      .to([line1Ref.current, line2Ref.current], {
        scaleX: 0,
        opacity: 0,
        duration: 1.5,
        ease: 'power2.inOut'
      }, '<0.3')
      
      // ========== PHASE 3: Extreme zoom + Monolith particles emerge (30-45%) ==========
      .to(bgImageRef.current, {
        scale: 12,
        y: '-55%',
        duration: 2.5,
        ease: 'power2.inOut'
      }, '+=0.1')
      
      .to([textBottomLeftRef.current, textBottomCenterRef.current], {
        opacity: 0,
        duration: 1,
        ease: 'power2.out'
      }, '<')
      
      // Monolith particles appear
      .to(monolithParticles.map(p => p.material), {
        opacity: 0.8,
        duration: 1,
        stagger: 0.002,
        ease: 'power2.out'
      }, '<0.5')
      
      .to(cam.position, {
        z: 600,
        duration: 2,
        ease: 'power2.inOut'
      }, '<')
      
      // ========== PHASE 4: Particles fly to form ring (45-55%) ==========
      .to(monolithParticles.map(p => p.position), {
        x: (i) => monolithParticles[i].userData.endPos.x,
        y: (i) => monolithParticles[i].userData.endPos.y,
        z: (i) => monolithParticles[i].userData.endPos.z,
        duration: 2,
        stagger: 0.003,
        ease: 'power2.inOut'
      })
      
      // Flash during formation
      .to(flashMat, {
        opacity: 0.3,
        duration: 0.3,
        ease: 'power2.in'
      }, '-=1')
      
      .to(flashMat, {
        opacity: 0,
        duration: 0.5,
        ease: 'power2.out'
      }, '-=0.5')
      
      // Portal ring appears
      .to(ringMaterial, {
        opacity: 1,
        duration: 1.5,
        ease: 'power2.out'
      }, '-=1.5')
      
      .to(glowRingMat, {
        opacity: 0.5,
        duration: 1.5,
        ease: 'power2.out'
      }, '<')
      
      .to(portalLight, {
        intensity: 30,
        duration: 1.5,
        ease: 'power2.out'
      }, '<')
      
      // ========== PHASE 5: Portal fully formed (55-65%) ==========
      // Dust and sparks appear
      .to(dustParticles.map(p => p.material), {
        opacity: 0.6,
        duration: 1.5,
        stagger: 0.01,
        ease: 'power2.out'
      }, '-=1')
      
      .to(sparkParticles.map(p => p.material), {
        opacity: 1,
        duration: 1,
        stagger: 0.01,
        ease: 'power2.out'
      }, '<0.3')
      
      .to(energyWaves.map(w => w.material), {
        opacity: 0.4,
        duration: 1,
        ease: 'power2.out'
      }, '<')
      
      // Center glow
      .to(centerGlowMat.uniforms.opacity, {
        value: 1,
        duration: 1.5,
        ease: 'power2.out'
      }, '<')
      
      .to(centerLight, {
        intensity: 15,
        duration: 1.5,
        ease: 'power2.out'
      }, '<')
      
      .to(bgImageRef.current, {
        opacity: 0,
        duration: 1.5,
        ease: 'power2.out'
      }, '<')
      
      // Fade monolith particles into ring
      .to(monolithParticles.map(p => p.material), {
        opacity: 0,
        duration: 1,
        ease: 'power2.out'
      }, '<0.5')
      
      // ========== PHASE 6: Enter portal (65-80%) ==========
      .to(cam.position, {
        z: 200,
        duration: 2.5,
        ease: 'power2.inOut'
      })
      
      // Second flash as we enter
      .to(flashMat, {
        opacity: 0.5,
        duration: 0.4,
        ease: 'power2.in'
      }, '-=1')
      
      .to(flashMat, {
        opacity: 0,
        duration: 0.8,
        ease: 'power2.out'
      })
      
      // About appears behind
      .to(aboutMaterial, {
        opacity: 0.5,
        duration: 2,
        ease: 'power2.out'
      }, '<-1.5')
      
      .to(aboutMesh.position, {
        z: -500,
        duration: 2.5,
        ease: 'power2.inOut'
      }, '<')
      
      // ========== PHASE 7: Through portal, portal fades (80-90%) ==========
      .to(cam.position, {
        z: 500,
        duration: 2.5,
        ease: 'power2.inOut'
      })
      
      // Portal fades
      .to([ringMaterial, glowRingMat], {
        opacity: 0,
        duration: 2,
        ease: 'power2.out'
      }, '<0.3')
      
      .to(dustParticles.map(p => p.material), {
        opacity: 0,
        duration: 1.5,
        ease: 'power2.out'
      }, '<')
      
      .to(sparkParticles.map(p => p.material), {
        opacity: 0,
        duration: 1.5,
        ease: 'power2.out'
      }, '<')
      
      .to(energyWaves.map(w => w.material), {
        opacity: 0,
        duration: 1.5,
        ease: 'power2.out'
      }, '<')
      
      .to(centerGlowMat.uniforms.opacity, {
        value: 0,
        duration: 1.5,
        ease: 'power2.out'
      }, '<')
      
      .to([portalLight, centerLight], {
        intensity: 0,
        duration: 1.5,
        ease: 'power2.out'
      }, '<')
      
      .to(aboutMesh.position, {
        z: 100,
        duration: 2.5,
        ease: 'power2.inOut'
      }, '<')
      
      .to(aboutMaterial, {
        opacity: 1,
        duration: 2,
        ease: 'power2.out'
      }, '<')
      
      // ========== PHASE 8: About locks at 100vh (90-100%) ==========
      .to(cam.position, {
        z: finalCamZ,
        duration: 2,
        ease: 'power1.out'
      })
      
      .to(aboutMesh.position, {
        z: finalAboutZ,
        duration: 2,
        ease: 'power1.out'
      }, '<');

    // ============================================
    // RESIZE
    // ============================================
    const handleResize = () => {
      cam.aspect = window.innerWidth / window.innerHeight;
      cam.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Recalculate about plane size
      const newHeight = 2 * Math.tan(vFov / 2) * targetDistance;
      const newWidth = newHeight * (window.innerWidth / window.innerHeight);
      aboutMesh.geometry.dispose();
      aboutMesh.geometry = new THREE.PlaneBufferGeometry(newWidth, newHeight);
    };
    window.addEventListener('resize', handleResize);

    // ============================================
    // CLEANUP
    // ============================================
    return () => {
      window.removeEventListener('resize', handleResize);
      cancelAnimationFrame(animationId);
      lenis.destroy();
      ScrollTrigger.getAll().forEach(t => t.kill());
      renderer.dispose();
    };
  }, []);

  return (
    <div 
      ref={containerRef} 
      style={{ 
        height: '100vh', 
        width: '100vw',
        position: 'relative', 
        overflow: 'hidden',
        backgroundColor: '#000'
      }}
    >
      {/* Background Image */}
      <div 
        ref={bgImageRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          transformOrigin: 'center 70%',
          willChange: 'transform, opacity'
        }}
      >
        <img 
          src="monolith.jpg"
          alt="Monolith"
          style={{
            width: '100%',
            height: '100%',
            objectFit: 'cover',
            objectPosition: 'center 70%'
          }}
        />
      </div>

      {/* Text Bottom Left */}
      <div
        ref={textBottomLeftRef}
        style={{
          position: 'absolute',
          bottom: '12%',
          left: '6%',
          color: '#c8e6d8',
          fontSize: 'clamp(11px, 1.3vw, 16px)',
          fontFamily: "'Courier New', monospace",
          textShadow: '0 0 20px rgba(61, 166, 122, 0.6)',
          maxWidth: '320px',
          lineHeight: 1.7,
          zIndex: 10,
          willChange: 'transform, opacity'
        }}
      >
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore.
      </div>

      {/* Center Text with Lines */}
      <div style={{ position: 'absolute', bottom: '8%', left: 0, right: 0, zIndex: 10 }}>
        <div
          ref={line1Ref}
          style={{
            position: 'absolute',
            left: '6%',
            top: '50%',
            width: '40%',
            height: '1px',
            background: 'linear-gradient(to right, transparent, rgba(61, 166, 122, 0.7))',
            transformOrigin: 'left center',
            boxShadow: '0 0 8px rgba(61, 166, 122, 0.5)'
          }}
        />
        
        <div
          ref={textBottomCenterRef}
          style={{
            position: 'absolute',
            left: '50%',
            transform: 'translateX(-50%)',
            color: '#5fcf9f',
            fontSize: 'clamp(12px, 1.8vw, 22px)',
            fontFamily: "'Courier New', monospace",
            textShadow: '0 0 25px rgba(61, 166, 122, 0.8)',
            whiteSpace: 'nowrap',
            fontWeight: 'bold',
            letterSpacing: '3px',
            willChange: 'transform, opacity'
          }}
        >
          VIVAMUS SAGITTIS LACUS
        </div>
        
        <div
          ref={line2Ref}
          style={{
            position: 'absolute',
            right: '6%',
            top: '50%',
            width: '40%',
            height: '1px',
            background: 'linear-gradient(to left, transparent, rgba(61, 166, 122, 0.7))',
            transformOrigin: 'right center',
            boxShadow: '0 0 8px rgba(61, 166, 122, 0.5)'
          }}
        />
      </div>

      {/* Three.js Canvas */}
      <canvas
        ref={canvasRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          pointerEvents: 'none',
          zIndex: 20
        }}
      />

      {/* Vignette */}
      <div 
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          background: 'radial-gradient(ellipse at center 65%, transparent 20%, rgba(5, 15, 10, 0.8) 100%)',
          pointerEvents: 'none',
          zIndex: 15,
          opacity: scrollProgress < 0.85 ? 1 : 0,
          transition: 'opacity 1s ease-out'
        }} 
      />

      {/* Scroll Indicator */}
      {scrollProgress < 0.03 && (
        <div 
          style={{
            position: 'absolute',
            bottom: '3%',
            right: '4%',
            color: '#5fcf9f',
            fontSize: '12px',
            fontFamily: "'Courier New', monospace",
            textShadow: '0 0 12px rgba(61, 166, 122, 0.8)',
            zIndex: 30,
            animation: 'pulseIndicator 2s ease-in-out infinite',
            letterSpacing: '2px'
          }}
        >
          ▼ SCROLL TO ENTER ▼
        </div>
      )}

      {/* Progress Bar */}
      <div 
        style={{
          position: 'fixed',
          top: '50%',
          right: '12px',
          transform: 'translateY(-50%)',
          width: '2px',
          height: '60px',
          background: 'rgba(61, 166, 122, 0.15)',
          borderRadius: '1px',
          zIndex: 100
        }}
      >
        <div 
          style={{
            width: '100%',
            height: `${scrollProgress * 100}%`,
            background: 'linear-gradient(to bottom, #3da67a, #5fcf9f)',
            borderRadius: '1px',
            boxShadow: '0 0 6px rgba(61, 166, 122, 0.8)',
            transition: 'height 0.15s ease-out'
          }}
        />
      </div>
    </div>
  );
};

ReactDOM.createRoot(document.getElementById('root')).render(<MonolithPortal />);
</script>
</body>
</html>